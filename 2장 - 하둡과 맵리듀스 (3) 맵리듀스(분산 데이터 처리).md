## 2장 - 하둡과 맵리듀스 (3) 맵리듀스(분산 데이터 처리)

​          

### Ⅰ  개요

​     

맵리듀스는 HDFS에 저장된 파일을 배치 방식으로 분석하는 시스템입니다.

여기서는 간단하게 틀만 잡고 자세한 내용은 Ⅲ에서 보겠습니다.

​     

**입력 파일 → 맵 → 리듀스 → 출력 파일**

1) 맵 : 입력된 파일(로그, 텍스트 파일 등)을 한 줄씩 읽어 데이터를 태깅, 분류(labeling)합니다.

2) 리듀스 : 맵이 출력한 결과를 요약합니다.

  

​     

### Ⅱ  구성 요소

​     

가이드를 보면 잡트래커(Job tracker)나 태스크트래커(Task tracker)라는 표현이 나옵니다.

**잡트래커와 태스크트래커 = 네임 노드로, 데이터가 저장된 공간 = 데이터 노드로 바꿔봅시다.**

잡트래커는 모든 것을 총괄하는 마스터 서버의 네임 노드, 태스크트래커는 잡트래커의 명령을 따르는 slave 서버의 네임 노드라는 계층이 있는 개념으로 구분하겠습니다.

​     

#### 1) 잡트래커

잡(Job)은 맵리듀스에서 하나의 작업 단위를 말합니다.

잡트래커는 전체 잡을 관리하는 역할을 맡습니다. 예를 들어 클라이언트가 새로운 잡을 실행하려고 하면, 잡트래커는 몇 번의 맵과 리듀스가 필요한지, 그 맵과 리듀스를 어떤 태스크트래커가 실시할지 등을 결정합니다.

​     

#### 2) 태스크트래커

클라이언트의 요구대로 맵리듀스를 데이터노드에서 실행시키는 데몬입니다.

잡트래커가 할당한 만큼 맵과 리듀스를 실행하며, 하트비트를 통해 잡트래커와 상태 여부를 통신합니다.

​     

​     

### Ⅲ  작동 방식(순서)

​ 

Ⅰ 에서 보았듯이 맵리듀스는 맵을 실행한 다음 리듀스를 실행하지만 세부적으로 파고들면 더 복잡합니다. 여기서는 세부 과정을 이해하도록 하겠습니다.



wordcount.png 그림을 통해 맵리듀스의 세부 흐름을 알 수 있습니다.**(split → map → shuffle → reduce)**

참고로 wordcount는 「시작하세요! 하둡 프로그래밍(개정2판)」의 p)105~127의 내용을 도식화한 그림입니다.

​     

1) 가장 좌측의 env.sh라는 입력 파일에는 라인(----)별로 데이터가 있습니다.

2) map에 들어가기 전에 split(스플릿)이라는 작업을 통해 라인별로 데이터를 나눕니다.

3) 라인별로 나눈 데이터를 WordCount Mapper라는 map에 입력해 라인별로 데이터를 읽어 map의 출력 데이터를 만들고 HDFS에 저장합니다.

4) map의 출력 데이터(중간 데이터)는 shuffle을 거쳐 reduce로 전달됩니다. shuffle은 파티셔너(partitioner)와 병합정렬(MergeSort)로 구분됩니다.

a) 파티셔너 : 맵의 출력 데이터 중 Key별로 해시값을 구해 해시값이 같은 데이터를 같은 파티션에 넣습니다. 즉, 유니크한 키의 개수만큼 파티션을 만들었지만 정렬은 되지 않은 상태입니다.

b) 병합정렬 : 서버마다 맵이 실행되는 속도가 다르기 때문에 맵의 결과물을 병합하는 과정이 필요합니다. 맵의 출력 데이터가 일정량이 되면 reduce로 넘어갑니다.

5) reduce는 map의 출력 데이터들을 입력받아 각 key가 몇 번 나왔는지 더해주는 과정입니다. reduce의 출력 데이터도 HDFS에 저장되며, 클라이언트가 최종적으로 원하는 결과물입니다.

​     

 cf)  <LongWritable, Text>와 같이 된 내용은 세부적인 내용에 해당하므로 넘기셔도 무방합니다.

자세한 내용은 「시작하세요! 하둡 프로그래밍(개정2판)」 책을 참고하시면 되고, 간략하게 설명드리면 NoSQL의 key와 value로 이해하시면 됩니다. 

​     

​     

### Ⅳ 부가 작동 방식

​     

#### 1) 체인

chain.png는 체인 방식의 예제를 나타낸 그림입니다.

자전거의 체인과 같이, 앞뒤가 서로 연결된 상태로 작동한다는 의미입니다. 예를 들어 map → reducer가 일반적인 방식이지만, map → map → reducer → map과 같이 다수의 map과 reducer를 연결할 수 있습니다.

​     

#### 2) 정렬

맵리듀스는 단순히 집계 함수만 사용하는 것은 아닙니다. 환경설정 파일을 조정하면 정렬, 조인, 성능 개선 등도 가능합니다. 

그런데 정렬은 2가지 이유로 성능이 좋지 않습니다.

첫째, 모든 데이터를 비교해서 순위를 구합니다.

둘째, 데이터를 병합할 수 없습니다.

즉, 파티션을 만들지 않아 reducer에서도 모든 데이터를 확인하고 원하는 위치에 넣기 위해 반복 작업이 자주 발생하기 때문입니다.

​     

​     

#### 참고 문헌

정재화, 「시작하세요! 하둡 프로그래밍(개정2판)」, 위키북스, 2016.

​     

B강사님의 강의노트
